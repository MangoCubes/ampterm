:PROPERTIES:
:ID:       2c0d8ff0-5fb3-4eb1-a979-403c08867912
:END:
#+TITLE: Architecture
* Note
- This is mostly for me to keep my thoughts in order.

* Action Management
- Actions are how each components communicate with each other.
- These are the actions users should use in their config:
  - User.<Mode>.<Action>
  - ToPlayerWorker.<Action>
  - Quit
* Component Design
** Variant Components
- A component may have variant subcomponents, depending on its state
- If a component has variant subcomponents, it has a component for each state, each named in a generic way
  - Example: PlaylistList has subcomponents named =error=, =loaded=, and =loading=
** Borders
- If a component does not have any subcomponents, borders are handled by the component directly
- If a component has subcomponents, but the border is expected to stay consistent throughout all states, then the borders are handled by the component directly
- If a component has subcomponents, and the border is expected to change depending on the state, then the borders are handled by each state semi-independently
  - Base design is handed out by the component

* Callback Handling
- =QueryWorker= is a component that fetches remote resources, and is the sole component that does this
** Request Handling
- The user does a certain action, and some functions are executed
- The return value of these functions is a certain action that is sent to =QueryWorker=
- The request contains a single =QueryParams= which specifies what query is being made, and the corresponding data
  - =QueryParams= has a many-to-one relationship with actual HTTP endpoints
  - E.g. "List Entire Playlist" action and "Add Playlist To Queue" are two different actions to the user, but both will query the same endpoint that returns the content of the given playlist to fulfil the roles
- When building the query, the struct contains a =ticket= value, which uniquely identifies the query, and the component can use this ticket to identify each responses
- Additionally, the =dest= field is filled automatically, which identifies the component that should receive the response
  - This is to ensure the response goes to the intended recipient
    - Sender and the receiver may not always be the same component
** Query Steps
- HighLevelQuery -> ToQueryWorker
- HighLevelQuery is a high-level object that corresponds closes to the user action
- ToQueryWorker is the object converted from HighLevelQuery that contains information about what actual queries that should be made
* Player Worker Management
** Queue Management
- Queue is stored as a VecDeque<Media>
- This queue does not delete any elements unless the user explicitly remove elements from it
- Current state contains the index of the music that is currently being played (Playing/Loading) or should be played when the play button is pressed (Idle) 
** State
- There are 3 states: Idle, Loading, and Playing
*** Idle
- This is where the player starts at when there is nothing being played
- This state contains an index named =play_next= which specifies what should be played in case the player is started
*** Loading
- When the player is started, we know the identifier of the song, but we do not know the exact location from which we can fetch the music
- This state represents this exact moment, and is expected to transition into Playing state almost immediately
- This state may be removed in the future where this is replaced with Playing state
*** Playing
- In this state, the music has been fetched from the URL and is now being played
** Action
- There are three actions, add to front, add next, and add last.
  - There is no add before the current one
|              | Idle                                                              | Loading / Playing                                      |
|--------------+-------------------------------------------------------------------+--------------------------------------------------------|
| Add To Front | Once the user starts playing, the added music plays first         | Stop the current loading, and play the requested music |
| Add Next     | Once the current music finishes, the added music plays next       | Same as Idle                                           |
| Add Last     | Once everything in the queue finishes, the added music plays next | Same as Idle                                           |
*** Add To Front
- Add an item so that the new one is played
- If music was being played, then that music is stopped and pushed next to the queue
*** Add Next
- Add an item so that once the current item finishes, the selected music is played
*** Add Last
- Add an item so that once everything in the queue (before adding the selected music) is exhausted, the selected music is played
* General
** State Change Management
- Components may have state, and they are marked with Stateful trait
- Drawing should not change state
** Player State Changes
- There are three stages: Idle, Loading and Playing
*** Idle
- Idle -> Loading: When the user selects a music file, and it requires further processing to get the corresponding resource link
- Idle -> Playing: When the user selects a music file, and it does not require further processing because we already have the URL to fetch the music file from
*** Loading
- Loading -> Idle: Playing is cancelled, or the OSClient fails to fetch the link
- Loading -> Playing: The OSClient successfully fetches the link
*** Playing
- Playing -> Idle: Music playing is stopped, or the current music is skipped and the queue is empty
- Playing -> Loading: Current music is skipped and the queue is not empty


